# 2024-01-09. Atelier #19

## Discussions

Déroulement de notre FF

* préambule
* on prend comme fil rouge une app qui permet de gérer une mailing-list.

* on présente l'exemple de formulaire _AVANT_ (ça sera notre fil rouge)
  * on présente le cc-simple-input-text (une version de cc-input-text super simplifié)
    * valeur, slot d'erreur et pi c'est tout
  * on présente le composant
  * la validation
  * le smart (et sa validation)

=> on peut simplifier l'écriture d'un formulaire
bcp de code
ça scale pas
=> on peut mutualiser la validation
=> on peut améliorer nos composants : les rendre plus "natifs"
en faire de véritables champs de formulaire


AVANT
```html
<composant>
  --- shadow DOM---
    <cc-input-text></cc-input-text>
  --- shadow DOM---
</composant>
```
le composant c'est le formulaire.
Il doit faire toute la glue (valeur/validation) entre lui meme et les inputs
Pour ça on utilise le lifecycle de Lit.

APRES
```html
<composant>
  <form>
    <cc-input-text></cc-input-text>
  </form>
</composant>
```
le cc-input-text se comporte comme un champ natif.
Et donc plus besoin de faire la glue

* Quelles sont les pistes qui s'offrent à nous ?
  * on enlève le shadow DOM
  * => pas retenu car on veut l'encapsulation des styles
  * slot (Lion fait ça)
  * => pas retenu car on déporte toute la glue
  * solution pure Lit (directive + controller) (un autre FF dédié ?)
  * => pas retenu car plus simple avec ElementInternals
  * => moins de code
  * => avec ELementInternals on gagne sur les deux tableaux

* on présente ElementInternals
  * présentation générale de l'API
  * on prend le cc-simple-input-text
  * on code en live le passage à ElementInternals
  * montrer `formAssociatedCallback()`


* on présente la validation
  * on code la validation native
    * penser à expliquer pourquoi `event.preventDefault();`
  * on montre qu'on peut prendre la main avec le `novalidate`
  * on montre la diff entre checkValidity et reportValidity
  * on a rendu notre composant compatible avec l'API ElementInternals & avec le system de validation natif. Youpi!
  * la validation native, c'est bien, mais elle n'est pas parfaite
    * event `invalid` mais pas d'event `valid`
    * on explique que ça ne nous va pas du tout : RGAA + tooltip = mauvaise idée !
    * UX nulle
      * un seul message d'erreur à la fois
      * tooltip
    * (on montre le trou dans la raquette : formCheckValidity n'appelle pas checkValidity des champs)
      * peut-être plus tard
  * on code le formulaire avec affichage des messages d'erreur en ligne (utilisation du slot)
    * piste 1: on implémente la validation dans le formulaire (utilisation du slot).
    * piste 2: on implémente reportValidity dans le composant et on montre qu'elle n'est pas appelée.
    * piste 3: l'event invalid. on peut définir le message d'erreur, mais on ne peut pas les reset car on n'a pas l'event `valid`
    * PAUSE!
    * piste 4: le composant implémente la validation


TODO
* on voudrait mutualiser la validation
  * piste 1: on s'appuie sur la validation native (type email, required, number) => ça complique plus qu'autre chose
  * piste 2: on implémente le concept de Validator
    * validation en tant que telle
    * les messages d'erreur (i18n)
* la glue finale
  * le ValidationController
  * le FormHandler + directive
  * le FormHelper (pour le smart)
* on continue de coder notre exemple et on lui ajoute la validation
  * validator
  * type email


### Differences avant après

* état initial
  * avant
    * pas d'erreur
    * le formulaire est considéré comme valide
  * après
    * les champs sont invalides
    * le formulaire est considéré comme invalide
* formulaire
  * avant
    * il n'y a pas nécessairement de <form>
  * après
    * le <form> devient obligatoire
*



## **Next**

* Validators
  * intégration
    * dans le cc-toggle
    * dans le cc-input-number (gros rework) => tentative en solo + debrief en équipe
  * écrire des tests unitaires (NON BLOQUANT)
  * d'autres validateurs ? (NON BLOQUANT)
    * isSSHPubKey ?
    * pattern ?
    * code postal ?
    * => regarder tous nos formulaires et lister les validations qui sont faites : Est-ce qu'on peut remplacer par un validateur
* on prépare des Frontend fridays
  * elementInternals (Florian doit nous parler de `delegateFocus`)
  * Validators
  * directives et Compagnie
* polish
* doc
* ADR
* Idées annexes
  * on peut adjoindre au lancement de l'évènement `requestimplicitsubmit`, un `this.closest('form')?.submit();`
  * on pourrait avoir une function util `closest(element)` qui traverse les shadowDOM
  * Penser à gérer la possibilité d'un champ required pour lequel la mention n'est pas visible : quand on a un seul champ de formulaire, on a pas besoin d'afficher la mention.
